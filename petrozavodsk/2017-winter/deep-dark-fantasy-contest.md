# Petrozavodsk Winter 2017. Day 5. Tsinghua U Deep Dark Fantasy Contest

+ [ ] [A. Random Numbers]
+ [ ] [B. Defense Tower]
+ [x] [C. Eulerian Orientation]
+ [ ] [D. Tube Master II]
+ [x] [E. Palindrome]
+ [ ] [F. Median on Binary Tree]
+ [ ] [G. Card Shuffling]
+ [ ] [H. Independent Events]
+ [ ] [I. Territory Game]

## C. Eulerian Orientation

首先，图的欧拉子图的数量是 $2^{|E| - |V| + c}$，其中 $c$ 是连通块的数量。

设边集是 $E$，选取的边集是 $F \subseteq E$,
那么 $\mathbb{E}[|F|] = \mathbb{E}[\sum_{e \in E} \sum_{f \in E} [e \in F][f \in F]] = \sum_{e \in E} \sum_{f \in E} \Pr[(e \in F) \wedge (f \in F)]$.

首先 $e, f$ 都不是割边，
如果 $e = f$，那么包含 $e$ 的欧拉子图的数量是 $2^{|E| - 1 - V + c}$.
如果 $e \neq f$，而且 $\{e, f\}$ 不是割集，那么包含 $e, f$ 的欧拉子图的数量是 $2^{|E| - 2 - V + c}$。如果 $\{e, f\}$ 是割集，那么数量是 $2^{|E| - 1 + V + c}$.

所以，只需要统计 $\{e, f\}$ 是割集的数量。一个方便的方法是随机化，给每条非树边一个 $[0, 2^{64})$ 的随机权值，树边的权值设为覆盖它的非树边的权值的异或。那么 $\{e, f\}$ 是割集当且仅当 $e, f$ 的权值相等。


## E. Palindrome

做这个题首先需要知道三个结论（可能只知道第一个也够了）：

1. 一个回文串的所有回文后缀的长度可以由$O(\log n)$个等差数列表示。具体是这样的：假设$l_0,l_1,l_2,...,l_m$是回文串$s$的$m$个回文后缀且$0=l_0 < l_1 < l_2 < \dots < l_m$。令$d_i=l_{i}-l_{i-1}$，如果$d_i=d_{i-1}$那么就把$l_i$和$l_{i-1}$归在同一个等差数列里面。可以证明这样只会产生$O(\log n)$个等差数列，具体证明参考Mikhail Rubinchik关于[EERTREE](https://arxiv.org/abs/1506.04862)的论文。

2. 令$l_1,l_2,...,l_m$是1中的某个等差数列，令公差为$d$，那么一定有$s(l_1,d)=s(l_2,d) = \dots s(l_{m-1},d) \ne s(l_m,d)$，其中$s(x,d)$表示$s$从$x$位置开始往后取$d$个字符得到的子串。证明很容易，略去。

3. 给出两个字符串$s$和$t$，已知$s(0,d)=s(d,d)=s((k-1)d,d)\ne s(kd,d)$，那么$t$和$s(0,), s(d, ), s(2d, ), \dots, s(kd, )$的最长公共前缀是一定是先不变，然后变化一下，之后以公差为$d$递减，其中$s(x,)$是以$x$开始的后缀。证明应该也很容易，略去。

回到原问题，如果会做两个区间，那么多个区间也是类似的，不妨只考虑两个区间。如果只有两个区间，答案的贡献来自于2部分：

1. 两个区间本身内部的回文串数目，这个是经典问题，离线+线段树就可以搞定，具体做法参考[这里](https://post.icpc-camp.org/d/547-2016-i)。
2. 左端点在第一个区间，右端点在第二个区间的回文串，其实根据回文中心的位置还可以细分为2部分。要计算这部分的贡献，需要解决下面的问题：已知两个串$s$和$t$的回文前缀和回文后缀，如何求出$st$的所有回文后缀。

可以发现，这些回文后缀来源于两个地方：

1. 回文中心在$t$中：一部分是$t$本来的回文后缀，另一部分是$t$的某些回文前缀扩展得来。
2. 回文中心在$s$中：这部分是$s$的某些回文后缀扩展而来。

先考虑第一种，令$t=uv$，$u$是一个回文串，那么只要$s$的某个后缀是$v^R$（$v$的翻转），那么就获得了一个回文后缀。根据最上面的三个结论，我们可以把$t$的一坨回文前缀一起处理。每坨回文前缀都是结论1中的一个等差数列，然后判断某个回文前缀能否扩展其实就是求$s^R$和$t(x,),t(x+d,d),\dots,t(x+(k-1),),t(x+kd,)$求最长公共前缀。根据结论2和3，我们就可以在$O(1)$时间内知道哪些回文前缀是可以扩展的（显然是一些连续的回文前缀）。

第二种也是类似的，不过是变成了$t$和$s^R(x,), s^R(x+d,),s^R(x+2d,),\dots,s^R(x+(k-1)d,), s^R(x+kd,)$求最长公共前缀而已。

事实上，在求得最长公共前缀的时候，我们已经可以计算新增的回文串的个数了，直接利用结论3就好了。于是我们已经会合并两个区间，以及计算两个区间的答案了，多个区间也是一样的过程。

还剩下一个问题，获取原始区间的所有回文前缀和回文后缀。这个可以直接套用EERTREE，或者用上述过程一个一个字符往后加，同时维护出当前的回文后缀。

中间细节可能比较多，在纸上好好画画应该就能搞定。复杂度$O((n+\sum k_i) \log n)$。
