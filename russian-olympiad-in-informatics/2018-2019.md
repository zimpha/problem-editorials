# ROI 2018/2019

+ [x] [模式串查找 (ROI 2019 Day2)](https://loj.ac/problem/3194)

## ROI 2019
### 模式串查找

题意：给出一个长度为$m$的模式串$p$。然后有个字符串$t$，一开始是空串，有$n$个操作：

+ `1 w`：把字符串$w$接在$t$后面
+ `2 pos len`：把$t_{pos .. pos+len-1}$这个子串接在$t$后面。

求出操作完后$p$在$t$中出现次数。

$1 \le m \le 200000, 1 \le n \le 10^4, |t| \le 10^{15}, 1 \le \sum |w| \le 2 \times 10^5$

题解：用可持久化`2-3 tree`维护字符串$t$，这样可以做到最后只有$O(n \log |t|)$的节点。然后我们需要快速统计跨过两个节点的出现次数。

对于每个节点，如果我们能维护它的最长前缀是$p$的后缀，以及它的最长后缀是$p$的前缀。那么跨过两个节点的出现次数就可以在$p$的前缀KMP树以及后缀KMP树上查询得到。就是树上两条路径的交，离线可以$O(\log m)$得到。

但是不好维护，考虑维护最长前缀/后缀是$p$的子串，那么对应的$p$的前后缀可以在前缀KMP树以及后缀KMP树上倍增得到。不妨考虑最长前缀，然后会涉及到两个节点合并后如何维护这个东西。

令$l_p,l_s,r_p,r_s$分别表示左边节点的最长前缀，左边节点对应的字符串，右边节点的最长前缀以及有边界点对应的字符串。如果$l_p \ne |l_s|$，那么合并后节点的最长前缀显然就是$l_p$。否则，这些前缀分别对应了$p$的一个子串，不妨设为$p[l_1,r_1]$和$p[l_2,r_2]$，我们要求出$p[l_1,r_1]+p[l_2,r_2]$的一个最长前缀是$p$的子串。考虑求出$p$的后缀数组，二分出这个字符串在后缀数组中的位置$x$，那么在$x$的左右两侧和这个字符串求个$lcp$就是答案。

复杂度$O(n \log |t| \log m)$。
